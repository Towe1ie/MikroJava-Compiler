package rs.ac.bg.etf.ln110181d;

import java_cup.runtime.*;
import org.apache.log4j.Logger;
import rs.ac.bg.etf.ln110181d.util.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import java.util.*;
import rs.etf.pp1.symboltable.structure.*;

parser code
{:
	Logger log = Logger.getLogger(getClass());

	public void syntax_error(Symbol cur_token)
	{
		int line = ((Symbol)cur_token).left;
		log.error("Syntax error (line " + line + ") Unexpected symbol " + (((Symbol)cur_token).value));
		//report_error("\nSintaksna greska ", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Unrecovered syntax error", cur_token);
	}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error("Fatal error" + message, info);
	}

	public void report_error(String message, Object info)
	{
		//dump_stack();
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
		{
			msg.append("(line ").append(((Symbol)info).left).append(")");
			msg.append(" Unexpected symbol " + (((Symbol)info).value));
		}
		log.error(msg.toString());
	}
	
	public void reportSemanticError(String message, int line)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Semantic error (line ").append(line + ") : ").append(message);
		log.error(sb.toString());
	}

	public void reportRecoveredSyntaxError(String message, int line)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Recovery syntax error (line ").append(line + ") : ").append(message);
		log.error(sb.toString());
	}
:}

scan with
{:
	Symbol s = this.getScanner().next_token();
	if (s != null)
	{
		if (s.value != null)
		{
			log.info(s.toString() + "(" + Utils.symToString(s.sym) + ") " + " " + s.value.toString());
		}
		else
		{
			log.info(s.toString() + "(" + Utils.symToString(s.sym) + ") " + " NULLL!!!");
		}
	}

	return s;
:}

init with
{:
	MyTab.init(); // Universe scope
:}

action code
{:
	// Declarations
	Obj currentDeclTypeObj = MyTab.noObj;
	int declKind = Obj.NO_VALUE;	

	// Classes
	Obj currentClassObj = MyTab.noObj;
	boolean classContext = false;
	Obj superClassObj = MyTab.noObj;

	// Methods
	Obj currentMethodObj = MyTab.noObj;
	Struct retType = MyTab.noType;
	boolean isVoid = false;
	boolean returnFound = false;
	int formalParamsCnt = 0;

	// Statements
	Stack<DesignatorInfo> designatorChainsStack = new Stack<DesignatorInfo>();
	public DesignatorInfo designatorTop()
	{
		return designatorChainsStack.peek();
	}
	
	Obj currentMethodCallObj = MyTab.noObj;
	int currentActualParam = 0;
	boolean isThisCall = false;

	boolean inWhile = false;

	boolean mainFound = false;

	class Info
	{
		public Object value;
		public Struct type;
		
		public Info(Object value, Struct type)
		{
			this.value = value;
			this.type = type;
		}
	}
	
	class DesignatorInfo
	{
		public Obj obj;
		public boolean isElementOfArray = false;
		public boolean isClassMember = false;

		public DesignatorInfo(Obj obj, boolean isElem)
		{
			this.obj = obj;
			this.isElementOfArray = isElem;
		}

		public DesignatorInfo(Obj obj)
		{
			this.obj = obj;
		}

		public Struct getType()
		{
			if (obj.getType().getKind() == Struct.Array && isElementOfArray)
				return obj.getType().getElemType();
			return obj.getType();
		}
	}	

	public Obj copyObj(Obj obj)
	{
		Obj newobj = new Obj(obj.getKind(), obj.getName(), obj.getType(), obj.getAdr(), obj.getLevel());
		SymbolDataStructure newSymbols = new HashTableDataStructure();
		for (Obj o : obj.getLocalSymbols())
			newSymbols.insertKey(o);
		newobj.setLocals(newSymbols);
		
		return newobj;
	}

	public Obj insertSymbol(int kind, String name, Struct type, int line)
	{
		Obj obj = MyTab.currentScope.findSymbol(name);
		boolean inherited = (obj instanceof MyObj) && ((MyObj)obj).isInherited;
		
		if (obj != null && obj != MyTab.noObj && !inherited)
		{
			parser.reportSemanticError("Symbol " + name + " already defined in the current scope", line);
			return MyTab.noObj;
		}
		else
			return MyTab.insert(kind, name, type, classContext);
	}
:}

// Keywords
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, WHILE, EXTENDS;

// Other tokens
terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;
terminal String STRING_CONST;

// Operators
terminal ADD, SUB, MUL, DIV, MOD, INC, DEC;
terminal EQ, NEQ, GRT, GRTE, LESS, LESSE;
terminal LAND, LOR;
terminal ASSIGN;
terminal SEMI, COMMA, DOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;

// Program
non terminal Program;
non terminal Obj ProgramName;
non terminal GlobalDeclarationsOpt, GlobalDeclList, GlobalDecl;

// Constants
non terminal ConstDeclLine, ConstDeclSequence, ConstDecl;
non terminal Obj Type;

// Variables
non terminal GlobalVarDeclLine, GlobalVarDeclSequence;
non terminal LocalVarDeclOpt, LocalVarDeclList, LocalVarDeclLine;
non terminal FieldsDeclOpt, FieldsDeclList, FieldDeclLine;
non terminal VarDeclSequence;
non terminal Obj VarDecl;

// Methods
non terminal MethodDeclOpt, MethodDeclList, MethodDecl, RetType;
non terminal FormalParamsOpt, FormalParamsList, FormalParam;
non terminal ActualParamsOpt, ActualParamsList, ActualParam;
non terminal Obj MethodName;

// Classes
non terminal ClassDecl, ExtendsOpt, ClassMethodDeclOpt;
non terminal Obj ClassName;

// Statements and Expressions
non terminal Statement, StatementListOpt, StatementList, OpenStatement, ClosedStatement, SimpleStatement;
non terminal DesignatorInfo Designator, DesignatorPart;
non terminal DesignatorName, DesignatorListOpt, DesignatorList;
non terminal Info Expr, Term, TermList, Factor;
non terminal Info Condition, CondTerm, CondFact;
non terminal String Addop, Mulop, Relop;
non terminal Info FuncCall;
non terminal Info Value;
non terminal DesignatorInfo CallName;
non terminal IncDec, LoopKeyword;

// =========================
// ===== Program Rules =====
// =========================

/* 1   */ Program ::= PROGRAM ProgramName GlobalDeclarationsOpt LBRACE:l MethodDeclOpt RBRACE
{:
	MyTab.chainLocalSymbols(MyTab.getCurrentScope().outerScopeObj);
	MyTab.closeScope();
	if (!mainFound)
		parser.reportSemanticError("Method \"main\" not found", lleft);
	parser.log.debug("****Program scope closed****");
	MyTab.dump(new MySymbolTableVisitor());
:};

/* 2   */ ProgramName ::= IDENT:pName
{:
	RESULT = insertSymbol(Obj.Prog, pName, MyTab.noType, pNameleft);
	if (RESULT == MyTab.noObj)
		parser.reportSemanticError("Invalid program name", pNameleft);
	MyTab.openScope(RESULT);
	parser.log.debug("****Program scope opened****");
:};

// ===============================
// ===== Global declarations =====
// ===============================
/* 2   */ GlobalDeclarationsOpt ::= GlobalDeclList;
/* 3   */ GlobalDeclarationsOpt ::= /* epsilon */;

/* 4   */ GlobalDeclList ::= GlobalDeclList GlobalDecl;
/* 5   */ GlobalDeclList ::= GlobalDecl;

/* 6   */ GlobalDecl ::= GlobalVarDeclLine;
/* 7   */ GlobalDecl ::= ConstDeclLine;
/* 8   */ GlobalDecl ::= ClassDecl;

// =============================
// ======== Const rules ========
// =============================
/* 8   */ ConstDeclLine ::= CONST Type ConstDeclSequence SEMI {: currentDeclTypeObj = MyTab.noObj; :};
/* 8   */ ConstDeclLine ::= CONST error:e SEMI {: parser.reportRecoveredSyntaxError("Wrong declaration of constant", eleft); :};
/* 9   */ ConstDeclSequence ::= ConstDeclSequence COMMA ConstDecl;
/* 10  */ ConstDeclSequence ::= ConstDecl;

/* 11  */ ConstDecl ::= error:e {: parser.reportRecoveredSyntaxError("Wrong declaration of constant", eleft); :};
/* 12  */ ConstDecl ::= IDENT:constName ASSIGN Value:info
{:
	if (!info.type.assignableTo(currentDeclTypeObj.getType()))
		parser.reportSemanticError("Type " + MyTab.getTypeObj(info.type).getName() + " not assignable to type " + currentDeclTypeObj.getName(), infoleft);
	else
		RESULT = insertSymbol(Obj.Con, constName, currentDeclTypeObj.getType(), infoleft);
:};

/* 21  */ Value ::= NUMBER:value 		{: RESULT = new Info(value, MyTab.intType); :};
/* 22  */ Value ::= CHAR_CONST:value 	{: RESULT = new Info(value, MyTab.charType); :};
/* 23  */ Value ::= BOOL_CONST:value 	{: RESULT = new Info(value, MyTab.boolType); :};
/* 24  */ Value ::= STRING_CONST:value	{: RESULT = new Info(value, MyTab.stringType); :};

// ===========================
// ======== Var rules ========
// ===========================
/* 13  */ GlobalVarDeclLine ::= Type {: declKind = Obj.Var; :} GlobalVarDeclSequence SEMI {: currentDeclTypeObj = MyTab.noObj; :};

/* 14  */ GlobalVarDeclSequence ::= GlobalVarDeclSequence COMMA VarDecl;
/* 15  */ GlobalVarDeclSequence ::= VarDecl;
/* 16  */ GlobalVarDeclSequence ::= error:e {: parser.reportRecoveredSyntaxError("Wrong declaration of variable", eleft); :};

/* 17  */ VarDeclSequence ::= VarDeclSequence COMMA VarDecl;
/* 18  */ VarDeclSequence ::= VarDecl;
		
/* 19  */ VarDecl ::= IDENT:varName
{:
	if (currentDeclTypeObj != MyTab.noObj && !(currentMethodObj == MyTab.noObj && declKind == Obj.Var && MyTab.currLevel > 0))
		RESULT = insertSymbol(declKind, varName, currentDeclTypeObj.getType(), varNameleft);
:};
/* 20  */ VarDecl ::= IDENT:varName LBRACKET RBRACKET
{:
	if (currentDeclTypeObj != MyTab.noObj && !(currentMethodObj == MyTab.noObj && declKind == Obj.Var && MyTab.currLevel > 0))
		RESULT = insertSymbol(declKind, varName, new MyStruct(Struct.Array, currentDeclTypeObj.getType()), varNameleft);
:};

// =============================
// ======== Class rules ========
// =============================
/* 25  */ ClassDecl ::= CLASS ClassName:classObj ExtendsOpt LBRACE FieldsDeclOpt ClassMethodDeclOpt RBRACE
{:
	if (currentClassObj != MyTab.noObj)
	{
		MyTab.chainLocalSymbols(MyTab.getCurrentScope().outerScopeObj.getType());
		MyTab.closeScope();
		parser.log.debug("Zatvoren opseg klase \"" + classObj.getName() +"\"");
	}
	currentClassObj = MyTab.noObj;
	superClassObj = MyTab.noObj;
	declKind = Obj.NO_VALUE;
	classContext = false;
:};

/* 128 */ ClassName ::= IDENT:className
{:
	MyStruct struct = new MyStruct(Struct.Class);
	RESULT = insertSymbol(Obj.Type, className, struct, classNameleft);
	if (RESULT != MyTab.noObj)
	{
		MyTab.openScope(RESULT);
		MyTab.getCurrentScope().isClassScope = true;
		parser.log.debug("Otvoren opseg klase \"" + className +"\"");
		declKind = Obj.Fld;
		struct.myObj = RESULT;
	}
	currentClassObj = RESULT;
	classContext = true;	
:};

/* 26  */ ExtendsOpt ::= EXTENDS IDENT:superClassName
{:
	Obj obj = MyTab.find(superClassName);
	if (obj == null || (obj.getKind() != Obj.Type && obj.getType().getKind() != Struct.Class))
		parser.reportSemanticError("Super class " + superClassName + " undefined", superClassNameleft);
	else
	{
		superClassObj = obj;
		((MyStruct)currentClassObj.getType()).superClass = superClassObj;
		for (Obj o : superClassObj.getType().getMembers())
		{
			Obj newObj = insertSymbol(o.getKind(), o.getName(), o.getType(), superClassNameleft);
			newObj.setAdr(o.getAdr());
			newObj.setFpPos(o.getFpPos());

			SymbolDataStructure newSymbols = new HashTableDataStructure();
			for (Obj loc : o.getLocalSymbols())
				newSymbols.insertKey(loc);
			newObj.setLocals(newSymbols);
			((MyObj)newObj).isInherited = true;
		}
	}
:};
/* 27  */ ExtendsOpt ::= error:e {: parser.reportRecoveredSyntaxError("Error in extension", eleft); :};
/* 28  */ ExtendsOpt ::= /* epsilon */;

/* 29  */ FieldsDeclOpt ::= FieldsDeclList
{:
	if (currentClassObj != MyTab.noObj)
		MyTab.chainLocalSymbols(MyTab.getCurrentScope().outerScopeObj.getType());
:};
/* 30  */ FieldsDeclOpt ::= /* epsilon */;

/* 31  */ FieldsDeclList ::= FieldDeclLine FieldsDeclList;
/* 32  */ FieldsDeclList ::= FieldDeclLine;
/* 33  */ FieldsDeclList ::= error:e {: parser.reportRecoveredSyntaxError("Wrong declaration of variable", eleft); :};
/* 34  */ FieldsDeclList ::= error:e SEMI {: parser.reportRecoveredSyntaxError("Wrong declaration of variable", eleft); :};

/* 35  */ FieldDeclLine ::= Type VarDeclSequence SEMI;

/* 36  */ ClassMethodDeclOpt ::= LBRACE MethodDeclOpt RBRACE;
/* 37  */ ClassMethodDeclOpt ::= /* epsilon */;

// ==============================
// ======== Method rules ========
// ==============================
/* 38  */ MethodDeclOpt ::= MethodDeclList;
/* 39  */ MethodDeclOpt ::= /* epsilon */;

/* 40  */ MethodDeclList ::= MethodDeclList MethodDecl;
/* 41  */ MethodDeclList ::= MethodDecl;

/* 42  */ MethodDecl ::= RetType MethodName:methObj LPAREN FormalParamsOpt RPAREN LocalVarDeclOpt LBRACE StatementListOpt RBRACE
{:
	if (currentMethodObj != MyTab.noObj)
	{
		if (!isVoid && !returnFound)
			parser.reportSemanticError("No return statement in method " + methObj.getName(), methObjleft);
		else if (isVoid && returnFound)
			parser.reportSemanticError("Return statement in void method " + methObj.getName(), methObjleft);
			
			int forParsCnt = (classContext) ? formalParamsCnt + 1 : formalParamsCnt;
			currentMethodObj.setAdr(forParsCnt);
			MyTab.chainLocalSymbols(MyTab.getCurrentScope().outerScopeObj);
			MyTab.closeScope();
			parser.log.debug("**** Method \"" + methObj.getName() + "\" scope closed");
	}
	formalParamsCnt = 0;
	declKind = Obj.NO_VALUE;
	currentMethodObj = MyTab.noObj;
	retType = MyTab.noType;
	returnFound = false;
:};

/* 50  */ RetType ::= VOID {: isVoid = true; :};
/* 51  */ RetType ::= IDENT:retTypeName
{:
	Obj retObj = MyTab.find(retTypeName);
	isVoid = false;
	
	if (retObj == null || retObj == MyTab.noObj)
		parser.reportSemanticError("Return type " + retTypeName + "undefined", retTypeNameleft);
	else
		if (retObj.getKind() != Obj.Type)
			parser.reportSemanticError("Return identifier " + retTypeName + " is not a type", retTypeNameleft);
		else
			retType = retObj.getType();
:};

/* 129 */ MethodName ::= IDENT:methodName
{:
	RESULT = insertSymbol(Obj.Meth, methodName, retType, methodNameleft);
	currentMethodObj = RESULT;
	
	if (RESULT != MyTab.noObj)
	{
		if (methodName.equals("main"))
		{
			mainFound = true;
			if (!isVoid)
				parser.reportSemanticError("Method \"main\" must return void", methodNameleft);
		}
		MyTab.openScope(RESULT);
		parser.log.debug("**** Method \"" + methodName + "\" scope opened");
		declKind = Obj.Var;
		if (classContext)
			insertSymbol(Obj.Var, "this", currentClassObj.getType(), methodNameleft);
	}
:};

// =====================================
// ======== Formal params rules ========
// =====================================

/* 52  */ FormalParamsOpt ::= FormalParamsList;
/* 53  */ FormalParamsOpt ::= /* epsilon */;

/* 54  */ FormalParamsList ::= FormalParamsList COMMA FormalParam;
/* 55  */ FormalParamsList ::= FormalParam;
/* 56  */ FormalParam ::= error:e {: parser.reportRecoveredSyntaxError("Wrong declaration of formal parameters", eleft); :};

/* 57  */ FormalParam ::= Type:typeObj IDENT:paramName
{:
	if (typeObj != MyTab.noObj && currentMethodObj != MyTab.noObj)
	{
		RESULT = insertSymbol(Obj.Var, paramName, typeObj.getType(), paramNameleft);
		formalParamsCnt++;
	}
:};
/* 58  */ FormalParam ::= Type:typeObj IDENT:paramName LBRACKET RBRACKET
{:
	if (typeObj != MyTab.noObj && currentMethodObj != MyTab.noObj)
	{
		RESULT = insertSymbol(Obj.Var, paramName, new MyStruct(Struct.Array, typeObj.getType()), paramNameleft);
		formalParamsCnt++;
	}	
:};

// =================================
// ======== Local var rules ========
// =================================
/* 43  */ LocalVarDeclOpt ::= LocalVarDeclList;
/* 44  */ LocalVarDeclOpt ::= /* epsilon */;

/* 45  */ LocalVarDeclList ::= LocalVarDeclLine LocalVarDeclList;
/* 46  */ LocalVarDeclList ::= LocalVarDeclLine;
/* 47  */ LocalVarDeclList ::= IDENT error:e SEMI {: parser.reportRecoveredSyntaxError("Wrong declaration of variable", eleft); :};
/* 48  */ LocalVarDeclList ::= error:e {: parser.reportRecoveredSyntaxError("Wrong declaration of variable", eleft); :};

/* 49  */ LocalVarDeclLine ::= Type VarDeclSequence SEMI;


// =================================
// ======== Statement rules ========
// =================================
/* 59  */ StatementListOpt ::= StatementList;
/* 60  */ StatementListOpt ::= /* epsilon */;

/* 61  */ StatementList ::= StatementList Statement;
/* 62  */ StatementList ::= Statement;

/* 63  */ Statement ::= OpenStatement;
/* 64  */ Statement ::= ClosedStatement;

/* 65  */ OpenStatement ::= IF LPAREN Condition RPAREN Statement;
/* 66  */ OpenStatement ::= IF LPAREN Condition RPAREN ClosedStatement ELSE OpenStatement;
/* 67  */ OpenStatement ::= LoopKeyword LPAREN Condition RPAREN OpenStatement {: inWhile = false; :};

/* 68  */ ClosedStatement ::= SimpleStatement;
/* 69  */ ClosedStatement ::= IF LPAREN Condition RPAREN ClosedStatement ELSE ClosedStatement;
/* 70  */ ClosedStatement ::= LoopKeyword LPAREN Condition RPAREN ClosedStatement {: inWhile = false; :};

/* xxx */ LoopKeyword ::= WHILE
{:
	inWhile = true;
:};

/* 71  */ Condition ::= CondTerm LOR CondTerm;
/* 72  */ Condition ::= CondTerm;
/* 73  */ Condition ::= error:e {: parser.reportRecoveredSyntaxError("Wrong condition expression", eleft); :};

/* 74  */ CondTerm ::= CondTerm LAND CondFact;
/* 75  */ CondTerm ::= CondFact;
			 
/* 76  */ CondFact ::= Expr:leftInfo Relop:op Expr:rightInfo
{:
	if (!leftInfo.type.compatibleWith(rightInfo.type))
		parser.reportSemanticError("Expressions not compatible", rightInfoleft);
	else if ((leftInfo.type.getKind() == Struct.Class || leftInfo.type.getKind() == Struct.Array) && (!op.equals("!=") && !op.equals("==")))
		parser.reportSemanticError("Only != and == operators allowed on class and array types", leftInfoleft);
:};
/* 77  */ CondFact ::= Expr:exprInfo
{:
	if (!exprInfo.type.equals(MyTab.boolType))
		parser.reportSemanticError("Expression must be of boolean type", exprInfoleft);
:};

/* xxx */ IncDec ::= INC;
/* xxx */ IncDec ::= DEC;

/* 79  */ SimpleStatement ::= Designator:desigInfo ASSIGN Expr:exInfo SEMI
{:
	if (desigInfo.obj.getKind() != Obj.Var && desigInfo.obj.getKind() != Obj.Fld)
    {
    	parser.reportSemanticError("Incorrect assignement, destination must be a variable, an element of array or a field", exInfoleft);
    }
	else
	{
		Struct destType, srcType;
		destType = desigInfo.getType();
		srcType = exInfo.type;	
						
		if (!srcType.compatibleWith(destType))
		{
			if (!(srcType instanceof MyStruct && ((MyStruct)srcType).superClass.getType().compatibleWith(destType)))
				parser.reportSemanticError("Destination and source type must be compatibile",exInfoleft);
		}
	}
:};
/* 79  */ SimpleStatement ::= Designator:desigInfo ASSIGN error:e SEMI {: parser.reportRecoveredSyntaxError("Wrong assignment expression", eleft); :};
/* 80  */ SimpleStatement ::= FuncCall SEMI;
/* 81  */ SimpleStatement ::= Designator:desigInfo IncDec SEMI
{:
	if (!(desigInfo.obj.getKind() == Obj.Var || desigInfo.obj.getKind() == Obj.Fld))
		parser.reportSemanticError("Identifier " + desigInfo.obj.getName() + " must be a variable, an array element or a field", desigInfoleft);
	if (!desigInfo.getType().equals(MyTab.intType))
		parser.reportSemanticError("Unary inc/dec allowed only on integers", desigInfoleft);
:};

/* 79  */ SimpleStatement ::= BREAK:br SEMI
{:
	if (inWhile == false)
		parser.reportSemanticError("Break statement allowed only in while loop", brleft);
:};
/* 80  */ SimpleStatement ::= RETURN:r SEMI
{:
	if (!isVoid)
		parser.reportSemanticError("Method must return a value", rleft);
:};
/* 81  */ SimpleStatement ::= RETURN Expr:exprInfo SEMI
{:
	returnFound = true;
	
	if (!isVoid && (retType == null || !retType.equals(exprInfo.type)))
	{
		parser.reportSemanticError("Expresion type doesn't match method return type", exprInfoleft);
	}
:};

/* 82  */ SimpleStatement ::= READ LPAREN Designator:desigInfo RPAREN SEMI
{:
	if (desigInfo.obj != MyTab.noObj && !(desigInfo.obj.getKind() == Obj.Var || desigInfo.obj.getKind() == Obj.Fld))
	{
		parser.reportSemanticError("Identifier " + desigInfo.obj.getName() + " must be a variable, an array element or a field", desigInfoleft);
	}

	if (desigInfo.obj != MyTab.noObj && !(desigInfo.obj.getType().equals(MyTab.intType) || desigInfo.obj.getType().equals(MyTab.charType) || desigInfo.obj.getType().equals(MyTab.boolType) || desigInfo.obj.getType().equals(MyTab.stringType)))
	{
		parser.reportSemanticError("Identifier " + desigInfo.obj.getName() + " must be a of int, char, bool or string type", desigInfoleft);
	}
:};

/* 83  */ SimpleStatement ::= READ LPAREN error:e RPAREN SEMI {: parser.reportRecoveredSyntaxError("Read function call error", eleft); :};
/* 84  */ SimpleStatement ::= PRINT LPAREN Expr:exprInfo RPAREN SEMI
{:
	if (!(exprInfo.type.equals(MyTab.intType) || exprInfo.type.equals(MyTab.charType) || exprInfo.type.equals(MyTab.boolType) || exprInfo.type.equals(MyTab.stringType)))
	{
		parser.reportSemanticError("Expression must be of int, char, bool or string type", exprInfoleft);
	}
:};

/* 85  */ SimpleStatement ::= PRINT LPAREN error:e RPAREN SEMI {: parser.reportRecoveredSyntaxError("Print function call error", eleft); :};
/* 86  */ SimpleStatement ::= PRINT LPAREN Expr:exprInfo COMMA NUMBER RPAREN SEMI
{:
	if (!(exprInfo.type.equals(MyTab.intType) || exprInfo.type.equals(MyTab.charType) || exprInfo.type.equals(MyTab.boolType) || exprInfo.type.equals(MyTab.stringType)))
	{
		parser.reportSemanticError("Expression must be of int, char, bool or string type", exprInfoleft);
	}
:};
/* 87  */ SimpleStatement ::= PRINT LPAREN error:e COMMA NUMBER RPAREN SEMI {: parser.reportRecoveredSyntaxError("Print function call error", eleft); :};
/* 88  */ SimpleStatement ::= LBRACE StatementListOpt RBRACE;

// =====================================
// ======== Function call rules ========
// =====================================

/* 89  */ FuncCall ::= CallName:callInfo LPAREN:l ActualParamsOpt RPAREN
{:
	RESULT = new Info(0, currentMethodCallObj.getType());
	
	int forParsCnt = (isThisCall) ? currentMethodCallObj.getAdr() - 1 : currentMethodCallObj.getAdr();

	if (currentActualParam < forParsCnt)
		parser.reportSemanticError("Insufficient number of arguments", lleft);
:};
/* 89  */ FuncCall ::= CallName LPAREN  error:e SEMI {: parser.reportRecoveredSyntaxError("Wrong function call", eleft); :};
/* 89  */ CallName ::= Designator:desigInfo
{:
	currentActualParam = 0;
	isThisCall = false;
	if (desigInfo.obj != MyTab.noObj && desigInfo.obj.getKind() != Obj.Meth)
	{
		parser.reportSemanticError("Identifier " + desigInfo.obj.getName() + " must be a global function or a method", desigInfoleft);
		//RESULT = new Info(0, MyTab.noType);
		currentMethodCallObj = MyTab.noObj;
	}
	else
	{
		currentMethodCallObj = desigInfo.obj;
		Struct methType = desigInfo.obj.getType();
		if (desigInfo.isClassMember)
			isThisCall = true;
		//RESULT = new Info(0, methType);
	}
	RESULT = desigInfo;
:};


/* 116 */ ActualParamsOpt ::= ActualParamsList;
/* 117 */ ActualParamsOpt ::= /* epsilon */;
/* 118 */ ActualParamsOpt ::= error:e {: parser.reportRecoveredSyntaxError("Wrong actual parameters in function call", eleft); :};

/* 119 */ ActualParamsList ::= ActualParamsList COMMA ActualParam;
/* 120 */ ActualParamsList ::= ActualParam;
/* 121 */ ActualParam ::= Expr:exprInfo
{:
	if (currentMethodCallObj != MyTab.noObj)
	{
		int forParsCnt = (isThisCall) ? currentMethodCallObj.getAdr() - 1 : currentMethodCallObj.getAdr();
		if (currentActualParam + 1 > forParsCnt)
		{
			parser.reportSemanticError("To many arguments", exprInfoleft);
		}
		else
		{
			Obj paramObj = null;
			Iterator<Obj> it = currentMethodCallObj.getLocalSymbols().iterator();
			if (isThisCall)
				it.next();
			for (int i = 0; i <= currentActualParam; ++i)
				paramObj = it.next();
			if (exprInfo.type != MyTab.noType && !paramObj.getType().compatibleWith(exprInfo.type))
			{
				if (!(exprInfo.type.getKind() == Struct.Array && paramObj.getType().getKind() == Struct.Array && paramObj.getType().getElemType() == MyTab.noType))
				parser.reportSemanticError("Actual parameter on position " + currentActualParam + ". type (" + MyTab.getTypeName(exprInfo.type)
										 + ") doesn't match with formal parameter type (" + MyTab.getTypeName(paramObj.getType()) + ")", exprInfoleft);
			}
		}
		currentActualParam++;
	}
:};

// ==================================
// ======== Designator rules ========
// ==================================
/* 89  */ Designator ::= DesignatorName DesignatorListOpt
{:
	RESULT = designatorChainsStack.pop();
	
:};
/* 89  */ DesignatorName ::= IDENT:desigName
{:
	Obj designatorObj = MyTab.find(desigName);
	if (designatorObj == null || designatorObj == MyTab.noObj)
	{
		parser.reportSemanticError("Identifier " + desigName + " undefined", desigNameleft);
		designatorChainsStack.push(new DesignatorInfo(MyTab.noObj));
	}
	else
	{
		designatorChainsStack.push(new DesignatorInfo(designatorObj));
		if (designatorTop().obj instanceof MyObj && ((MyObj)designatorTop().obj).isClassMember)
				designatorTop().isClassMember = true;
	}
:};

/* 90  */ DesignatorListOpt ::= DesignatorList;
/* 91  */ DesignatorListOpt ::= /* epsilon */;

/* 92  */ DesignatorList ::= DesignatorList DesignatorPart;
/* 93  */ DesignatorList ::= DesignatorPart;

/* 94  */ DesignatorPart ::= DOT IDENT:desigName
{:
	if (designatorTop().obj != MyTab.noObj)
	{
		if (designatorTop().obj.getType().getKind() != Struct.Class)
			parser.reportSemanticError("Identifier " + designatorTop().obj.getName() + " is not of class type", desigNameleft);
		else
		{
			Obj desigObj = MyTab.noObj;
			boolean found = false;
			for (Obj o : designatorTop().obj.getType().getMembers())
			{
				if (o.getName().equals(desigName))
				{
					desigObj = o;
					found = true;
					break;
				}
			}
			
			if (!found)
			{
				String className = MyTab.getTypeName(designatorTop().obj.getType());
				parser.reportSemanticError("Identifier " + desigName + " is not a member of the class " + className, desigNameleft);
			}
			else
			{
				designatorTop().obj = desigObj;
				designatorTop().isClassMember = true;
			}
		}
	}
:};

/* 95  */ DesignatorPart ::= LBRACKET Expr:exprInfo RBRACKET
{:
	if (designatorTop().obj.getType().getKind() != Struct.Array)
		parser.reportSemanticError("Identifier " + designatorTop().obj.getName() + " is not an array", exprInfoleft);
	else
	{
		if (!exprInfo.type.equals(MyTab.intType))
			parser.reportSemanticError("Index expression is not of int type", exprInfoleft);
		designatorTop().isElementOfArray = true;
	}
:};
/* 96  */ DesignatorPart ::= LBRACKET error:e RBRACKET {: parser.reportRecoveredSyntaxError("Wrong index expression", eleft); :};

// ==================================
// ======== Expression rules ========
// ==================================
/* 103 */ Expr ::= SUB TermList:termListInfo
{:
	if (!termListInfo.type.equals(MyTab.intType))
	{
		parser.reportSemanticError("Unary negation operator allowed only on int type", termListInfoleft);
		RESULT = new Info(0, MyTab.noType);
	}
	else
		RESULT = new Info(0, termListInfo.type);
:};
/* 104 */ Expr ::= TermList:termListInfo
{:
	RESULT = termListInfo;
:};

/* 105 */ TermList ::= TermList:leftInfo Addop:opString Term:rightInfo
{:
	if (leftInfo.type.equals(MyTab.intType) && rightInfo.type.equals(MyTab.intType) ||
		leftInfo.type.equals(MyTab.stringType) && rightInfo.type.equals(MyTab.stringType) && opString.equals("+"))
		RESULT = new Info(0, leftInfo.type);
	else
	{
		RESULT = new Info(0, MyTab.noType);
		if (opString.equals("+"))
			parser.reportSemanticError("Operator " + opString + " allowed only on string and int operands", leftInfoleft);
		else
			parser.reportSemanticError("Operator " + opString + " allowed only on int operands", leftInfoleft);
	}
:};

/* 106 */ TermList ::= Term:termInfo
{:
	RESULT = termInfo;
:};

/* 107 */ Term ::= Term:termInfo Mulop:opString Factor:factorInfo
{:
	if (!(factorInfo.type.equals(MyTab.intType) && termInfo.type.equals(MyTab.intType)))
	{
		parser.reportSemanticError("Operator " + opString + " allowed only on int type", termInfoleft);
		RESULT = new Info(0, MyTab.noType);
	}
	else
		RESULT = new Info(0, MyTab.intType);
:};

/* 108 */ Term ::= Factor:factorInfo
{:
	RESULT = factorInfo;
:};

/* 109 */ Factor ::= Designator:desigInfo
{:
	RESULT = new Info(0, desigInfo.getType());
:};
/* 110 */ Factor ::= FuncCall:funcCallInfo
{:
	RESULT = funcCallInfo;
:};

/* 111 */ Factor ::= Value:valueInfo
{:
	RESULT = valueInfo;
:};

/* 112 */ Factor ::= NEW IDENT:typeName
{:
	Obj typeObj = MyTab.find(typeName);
	if (typeObj == null || typeObj.getKind() != Obj.Type || typeObj.getType().getKind() != Struct.Class)
	{
		parser.reportSemanticError("Identifier " + typeName + " is not a class name", typeNameleft);
		RESULT = new Info(0, MyTab.noType);
	}
	else
		RESULT = new Info(0, typeObj.getType());
:};

/* 113 */ Factor ::= NEW IDENT:typeName LBRACKET Expr:exprInfo RBRACKET
{:
	Obj typeObj = MyTab.find(typeName);
	if (typeObj == null || typeObj.getKind() != Obj.Type)
	{
		parser.reportSemanticError("Identifier " + typeName + " is not a type", typeNameleft);
		RESULT = new Info(0, MyTab.noType);
	}
	else if (!exprInfo.type.equals(MyTab.intType))
	{
		parser.reportSemanticError("Expression must be of int type", typeNameleft);
		RESULT = new Info(0, MyTab.noType);
	}
	else
		RESULT = new Info(0, new MyStruct(Struct.Array, typeObj.getType()));
:};

/* 114 */ Factor ::= NEW IDENT LBRACKET error:e RBRACKET {: parser.reportRecoveredSyntaxError("Wrong allocation expression", eleft); :};
/* 115 */ Factor ::= LPAREN Expr:exprInfo RPAREN
{:
	RESULT = exprInfo;
:};




/* 121 */ Addop ::= ADD {: RESULT = "+"; :};
/* 122 */ Addop ::= SUB {: RESULT = "-"; :};

/* 123 */ Mulop ::= MUL {: RESULT = "*"; :};
/* 124 */ Mulop ::= DIV {: RESULT = "/"; :};
/* 125 */ Mulop ::= MOD {: RESULT = "%"; :};
		 
/* 126 */ Relop ::= EQ {: RESULT = "=="; :};
/* 126 */ Relop ::= NEQ {: RESULT = "!="; :};
/* 126 */ Relop ::= GRT {: RESULT = ">"; :};
/* 126 */ Relop ::= GRTE {: RESULT = ">="; :};
/* 126 */ Relop ::= LESS {: RESULT = "<"; :};
/* 126 */ Relop ::= LESSE {: RESULT = "<="; :};


/* 128 */ Type ::= IDENT:typeName
{:
	Obj typeObjNode = MyTab.find(typeName);
	if (typeObjNode == null || typeObjNode == MyTab.noObj)
	{
		parser.reportSemanticError("Type " + typeName + " undefined", typeNameleft);
		RESULT = MyTab.noObj;
	}
	else
	{
		if (typeObjNode.getKind() == Obj.Type)
			RESULT = typeObjNode;
		else
		{
			parser.reportSemanticError(typeName + " is not a type", typeNameleft);
			RESULT = MyTab.noObj;
		}
	}
	currentDeclTypeObj = RESULT;
:};



